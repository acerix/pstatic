<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>sWebGL</title>
<link rel="stylesheet" href="style.css">
<link rel="icon" href="favicon.ico" type="image/x-icon" />
</head>
<body>

<script id="shader-vs" type="text/x-vertex_shader">

attribute vec2 a_position;

void main(void) {
  gl_Position = vec4(a_position, 0.0, 1.0);
}

</script>

<script id="shader-fs" type="text/x-fragment_shader">

precision lowp float;

uniform float u_resolution;
uniform float u_scale;
uniform float u_speed;
uniform vec2 u_transform;
uniform vec3 u_color_params;
uniform float u_time;

void main() {

  // Get final coordinates
  float x = ( gl_FragCoord.x / u_resolution - u_transform.x ) / u_scale;
  float y = ( gl_FragCoord.y / u_resolution - u_transform.y ) / u_scale;

  // Return value of the function
  float z = 0.0;

  // Function to calculate z from x and y
  //z = x - y; // line
  //z = x * x - y; // parabola
  //z = x * y - 1.0; // hyperbola
  z = x * x + y * y; // circle
  //z = -1.0 + x * x * x * y * y * y; // fermat curve
  //z = -2.0 * x * x + x * x * x * x + 2.0 * y * y + 2.0 * x * x * y * y + y * y * y * y;  // lemniscate of bernoulli
  //z = 0.0 - x * x + x * x * x * x + y * y;  // lemniscate of gerono
  //z = x * x * x - 3.0 * x * y + y * y * y;  // folium of descartes

  // Set pixel colour
  //gl_FragColor.r = mod(z * u_color_params.r - u_time / 128.0, 1.0);
  //gl_FragColor.g = mod(z * u_color_params.g - u_time / 128.0, 1.0);
  //gl_FragColor.b = mod(z * u_color_params.b - u_time / 128.0, 1.0);
  gl_FragColor.r = sin(z * u_color_params.r - u_time * u_speed) / 2.0 + 0.5;
  gl_FragColor.g = sin(z * u_color_params.g - u_time * u_speed) / 2.0 + 0.5;
  gl_FragColor.b = sin(z * u_color_params.b - u_time * u_speed) / 2.0 + 0.5;

}

</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>

<script type="module">
'set strict'

import {sWebGL} from './sWebGL.mjs'
import {sParams} from './sParams.mjs'
import {sPanel} from './sPanel.mjs'
import {sMouse} from './sMouse.mjs'
import {sKeys} from './sKeys.mjs'

import {sDemo} from './sDemo.mjs'


window.onload = function() {

  // Keep track of where the mouse was while dragging
  var mouse_left_drag_last_position = [0, 0]

  // Keep track of when each button is pressed to know which button was pressed first
  var mouse_left_last_click = 0
  var mouse_right_last_click = 0

  // Increment the zoom level (scale)
  var incrementZoom = function(increment, towards) {

    var factor = 1 + increment / 16

    // Reverse zoom direction when scale is negative
    if (param_handler.params.z < 0) {
      factor = 1 / factor
    }

    var new_zoom = +(factor * param_handler.params.z).toFixed(6)
    if (new_zoom === param_handler.params.z) {
      new_zoom = +(+param_handler.params.z + increment * 0.000001).toFixed(6)
    }
    param_handler.params.z = new_zoom
    updateScaleLocation()

    // Zoom towards the target
    /*
    param_handler.params.x = ((+param_handler.params.x) - (towards[0] - swgl.canvas.centre[0]) / 128 ).toFixed(5)
    param_handler.params.y = ((+param_handler.params.y) - (towards[1] - swgl.canvas.centre[1]) / 128 ).toFixed(5)
    swgl.gl.uniform2f(swgl.transform_location, param_handler.params.x, param_handler.params.y)
    */

    param_handler.update()
  }

  // Move position (translate)
  var movePosition = function(x, y) {
    param_handler.params.x = (x + +param_handler.params.x).toFixed(5)
    param_handler.params.y = (y + +param_handler.params.y).toFixed(5)
    updateTransformLocation()
    param_handler.update()
  }

  // Init Web GL
  var swgl = new sWebGL({
    plugins: {

      'mouse': new sMouse({
        onDown: {

          // left-click
          0: function() {
            mouse_left_last_click = +new Date()

            // Record position for dragging
            mouse_left_drag_last_position = swgl.plugins.mouse.p.slice(0)
          },

          // right-click
          2: function() {
            mouse_right_last_click = +new Date()
          },

        },
        whileDown: {

          // left-click
          0: function() {
            // if right-click is not also pressed
            if (swgl.plugins.mouse.b[2] === 0) {
              // Move by dragging
              var z = param_handler.params.z * 7
              var mouse_delta = [
                swgl.xToScreenBasis(mouse_left_drag_last_position[0], z) - swgl.xToScreenBasis(swgl.plugins.mouse.p[0], z),
                swgl.yToScreenBasis(mouse_left_drag_last_position[1], z) - swgl.yToScreenBasis(swgl.plugins.mouse.p[1], z)
              ]
              mouse_left_drag_last_position = swgl.plugins.mouse.p.slice(0)
              if (mouse_delta[0] || mouse_delta[1]) {
                movePosition(-mouse_delta[0], mouse_delta[1])
              }

            }
          },

          // right-click
          2: function() {
            // ignore when left-click is also pressed
            if (swgl.plugins.mouse.b[0] !== 0) {
              return
            }
            // move towards drag position
            movePosition(
              (swgl.canvas.centre[0] - swgl.plugins.mouse.p[0]) / 4096,
              -(swgl.canvas.centre[1] - swgl.plugins.mouse.p[1]) / 4096
            )
          },

        },
        onWheel: function(i) {
          incrementZoom(-i, swgl.plugins.mouse.p)
        },

      }),

      'keys': new sKeys({
        onDown: {

          // esc: Reset
          27: function() {
            param_handler.params.x = param_handler.params.y = 0
            param_handler.params.z = 0.1
            param_handler.update()
          },

          // ←: Left
          37: function() {
            movePosition(-1,  0)
          },
          // ↑: Up
          38: function() {
            movePosition( 0,  1)
          },
          // →: Right
          39: function() {
            movePosition( 1,  0)
          },
          // ↓: Down
          40: function() {
            movePosition( 0, -1)
          },

          //
          70: function() {
            console.log(atob('UGF5IHJlc3BlY3Rz'))
          },

          // +: Zoom in
          107: function() {
            incrementZoom(1)
          },
          // -: Zoom out
          109: function() {
            incrementZoom(-1)
          },

        }
      })

    }
  })

  // Callback functions when params are changed
  var updateTransformLocation = function() {
    swgl.gl.uniform2f(
      swgl.transform_location,
      +param_handler.params.x + swgl.canvas.centre[0] / swgl.smallestScreenEdge(),
      +param_handler.params.y + swgl.canvas.centre[1] / swgl.smallestScreenEdge()
    )
  }
  var updateScaleLocation = function(v) {
    swgl.gl.uniform1f(swgl.scale_location, param_handler.params.z)
  }

  // Draw something as a demo
  var actor = new sDemo()
  swgl.gl.uniform3f(swgl.color_params_location, actor.colour_frequencies[0], actor.colour_frequencies[1], actor.colour_frequencies[2])

  // Get params from URL hash and update URL when they change
  var param_handler = new sParams({
    onchange: {
      'x': updateTransformLocation,
      'y': updateTransformLocation,
      'z': updateScaleLocation
    }
  })

  // Default params
  param_handler.params = {

      // Scroll position
      x: 0,
      y: 0,

      // Zoom
      z: 0.1,

  }

  // Parse supplies params
  param_handler.parse(false)

  // Update params in URL hash
  param_handler.update()

  // Set sWebGL params
  updateTransformLocation()
  updateScaleLocation()

  // Set actor params from URL hash
  for (var param_name in param_handler.params) {
    var indexes = param_name.split('_')
    switch (indexes[0]) {

      case 'colour_frequencies':
        actor.colour_frequencies[indexes[1]] = param_handler.params[param_name]
        break;

      case 'speed':
        actor.speed[indexes[1]] = param_handler.params[param_name]
        break;

    }
  }

  // Point in time counter (eg. frame number)
  var pot = 0

  var color_offsets = vec3.create()
  vec3.random(color_offsets)
  var color_frequencies = vec3.create()
  vec3.random(color_frequencies, 0.05)

  swgl.drawScene = function() {

    pot++

    swgl.gl.uniform1f(swgl.time_location, pot)

    if (typeof swgl.plugins === 'object') {
      for (var i in swgl.plugins) if (swgl.plugins[i].hasOwnProperty('whileDown')) {
        for (var j in swgl.plugins[i].whileDown) {
          if (swgl.plugins[i].b[j]) {
            swgl.plugins[i].whileDown[j]()
          }
        }
      }
    }

    // Draw actors
    swgl.gl.drawArrays(swgl.gl.TRIANGLE_STRIP, 0, 4)

    // Reset initial position
    //actor.reset()

    // Iterate
    //actor.iterate()
  }

  // Draw the actor control panel
  var panel = new sPanel()

  panel.drawSliders(
    actor.speed,
    'speed',
    {
      min: 0,
      max: 10,
      onchange: function(name) {
        var indexes = name.split('_')
        param_handler.params[name] = actor.speed[indexes[1]].toFixed(3)
        swgl.speed_location[indexes[1]] = param_handler.params[name]
        swgl.gl.uniform1f(swgl.speed_location, actor.speed[0])
        param_handler.update()
      },
    }
  )
  panel.drawSliders(
    actor.colour_frequencies,
    'colour_frequencies',
    {
      min: -100,
      max: 100,
      onchange: function(name) {
        var indexes = name.split('_')
        param_handler.params[name] = actor.colour_frequencies[indexes[1]].toFixed(3)
        swgl.color_params_location[indexes[1]] = param_handler.params[name]
        swgl.gl.uniform3f(swgl.color_params_location, actor.colour_frequencies[0], actor.colour_frequencies[1], actor.colour_frequencies[2])
        param_handler.update()
      },
    }
  )

}

</script>

</body>
</html>
