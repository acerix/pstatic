<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>sWebGL</title>
<link rel="stylesheet" href="style.css">
<link rel="icon" href="favicon.ico" type="image/x-icon" />
</head>
<body>

<script id="shader-fs" type="text/x-fragment_shader">

precision lowp float;

// point in time
uniform float u_time;

// transform basis
uniform vec2 translate;
uniform vec2 scale;
uniform float rotate;

// @todo convert above 3 to a matrix
uniform mat2 transform_canvas_to_cartesian;

// @todo put in vec3?
uniform float r;
uniform float g;
uniform float b;

uniform vec4 u_color;

void main() {

  float x = ( gl_FragCoord.x + translate.x ) * scale.x / 256.0;
  float y = ( gl_FragCoord.y + translate.y ) * scale.y / 256.0;

  // transform fragcoord to cartesian coord
  // @todo simplify to one matrix

  //float sin_theta = sin(rotate);
  //float cos_theta = cos(rotate);

  //float x2 = cos_theta * x - sin_theta * y;
  //float y2 = sin_theta * x + cos_theta * y;

  //x = x2;
  //y = y2;


  // the return value of the function
  float z = 0.0;

  // function to calculate z from x and y
  z = x - y; // line
  //z = x * x - y; // parabola
  //z = x * y - 1.0; // hyperbola
  //z = x * x + y * y; // circle
  //z = -1.0 + x * x * x * y * y * y; // fermat curve
  //z = -2.0 * x * x + x * x * x * x + 2.0 * y * y + 2.0 * x * x * y * y + y * y * y * y;  // lemniscate of bernoulli
  //z = 0.0 - x * x + x * x * x * x + y * y;  // lemniscate of gerono
  //z = x * x * x - 3.0 * x * y + y * y * y;  // folium of descartes

  // animate by varying the result with u_time
  //z = z * -u_time;
  //z = z + u_time;


  // grey
  //gl_FragColor.r = gl_FragColor.g = gl_FragColor.b = z;
  //gl_FragColor.r = gl_FragColor.g = gl_FragColor.b = mod(z - u_time / 16.0, 1.0);

  // set pixel colours
  //gl_FragColor.r = mod(z * r - u_time / 128.0, 1.0);
  //gl_FragColor.g = mod(z * g - u_time / 128.0, 1.0);
  //gl_FragColor.b = mod(z * b - u_time / 128.0, 1.0);



  //gl_FragColor = u_color;

  gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0);

}

</script>

<script id="shader-vs" type="text/x-vertex_shader">

attribute vec2 a_position;

uniform float u_scale;

uniform vec2 u_transform;

uniform vec2 u_resolution;

void main() {

  // convert from pixels to 0...1
  vec2 clip_space = a_position / u_resolution;

  // scale
  clip_space *= u_resolution.y * u_scale;

  // translate
  clip_space += u_transform;

  gl_Position = vec4(clip_space, 0.0, 1.0);

}

</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>

<script type="module">
'set strict'

import {sWebGL} from './sWebGL.mjs'
import {sParams} from './sParams.mjs'
import {sPanel} from './sPanel.mjs'
import {sMouse} from './sMouse.mjs'
import {sKeys} from './sKeys.mjs'

import {sDemo} from './sDemo.mjs'


window.onload = function() {

  // Keep track of where the mouse was while dragging
  var mouse_left_drag_last_position = [0, 0]

  // Keep track of when each button is pressed to determine which button was pressed first
  var mouse_left_last_click = 0
  var mouse_right_last_click = 0


  // Increment the zoom level (scale)
  var incrementZoom = function(increment, towards) {
    param_handler.params.z = ((1 - increment / 16) * param_handler.params.z).toFixed(5)
    swgl.gl.uniform1f(swgl.scale_location, param_handler.params.z)

    // Zoom towards the target
    /*
    param_handler.params.x = ((+param_handler.params.x) - (towards[0] - swgl.canvas.centre[0]) / 128 ).toFixed(5)
    param_handler.params.y = ((+param_handler.params.y) - (towards[1] - swgl.canvas.centre[1]) / 128 ).toFixed(5)
    swgl.gl.uniform2f(swgl.transform_location, param_handler.params.x, param_handler.params.y)
    */

    param_handler.update()
  }

  // Move position (translate)
  var movePosition = function(x, y) {
    param_handler.params.x = (x + +param_handler.params.x).toFixed(5)
    param_handler.params.y = (y + +param_handler.params.y).toFixed(5)
    swgl.gl.uniform2f(swgl.transform_location, param_handler.params.x, param_handler.params.y)
    swgl.gl.clear(swgl.gl.COLOR_BUFFER_BIT)
    param_handler.update()
  }

  // Init Web GL
  var swgl = new sWebGL({
    plugins: {
      'mouse': new sMouse({
        onDown: {

          // left-click
          0: function() {
            mouse_left_last_click = +new Date()

            // Record position for dragging
            mouse_left_drag_last_position = swgl.plugins.mouse.p.slice(0)
          },

          // right-click
          2: function() {
            mouse_right_last_click = +new Date()
          },

        },
        whileDown: {

          // left-click
          0: function() {
            // if right-click is not also pressed
            if (swgl.plugins.mouse.b[2] === 0) {
              // Move by dragging
              var z = param_handler.params.z * 7
              var mouse_delta = [
                swgl.xToScreenBasis(mouse_left_drag_last_position[0], z) - swgl.xToScreenBasis(swgl.plugins.mouse.p[0], z),
                swgl.yToScreenBasis(mouse_left_drag_last_position[1], z) - swgl.yToScreenBasis(swgl.plugins.mouse.p[1], z)
              ]
              mouse_left_drag_last_position = swgl.plugins.mouse.p.slice(0)
              if (mouse_delta[0] || mouse_delta[1]) {
                movePosition(-mouse_delta[0], mouse_delta[1])
              }

            }
          },

          // right-click
          2: function() {
            // ignore when left-click is also pressed
            if (swgl.plugins.mouse.b[0] !== 0) {
              return
            }
            // move towards drag position
            movePosition(
              (swgl.canvas.centre[0] - swgl.plugins.mouse.p[0]) / 4096,
              -(swgl.canvas.centre[1] - swgl.plugins.mouse.p[1]) / 4096
            )
          },

        },
        onWheel: function(i) {
          incrementZoom(i, swgl.plugins.mouse.p)
        },

      }),

      'keys': new sKeys({
        onDown: {

          // up: Up
          38: function() {
            movePosition(0, 32)
          },
          // left: Left
          37: function() {
            movePosition(-32, 0)
          },
          // down: Down
          40: function() {
            movePosition(0, -32)
          },
          // right: Right
          39: function() {
            movePosition(32, 0)
          },

          // +: Zoom in
          107: function() {
            incrementZoom(1)
          },
          // -: Zoom out
          109: function() {
            incrementZoom(-1)
          },

        }
      })

    }
  })

  // Callback functions when params are changed
  var param_onchange_callbacks = {
    'x': function(v) {
      swgl.gl.uniform2f(swgl.transform_location, param_handler.params.x, param_handler.params.y)
      swgl.gl.clear(swgl.gl.COLOR_BUFFER_BIT)
    },
    'y': function(v) {
      swgl.gl.uniform2f(swgl.transform_location, param_handler.params.x, param_handler.params.y)
      swgl.gl.clear(swgl.gl.COLOR_BUFFER_BIT)
    },
    'z': function(v) {
      swgl.gl.uniform1f(swgl.scale_location, param_handler.params.z)
      swgl.gl.clear(swgl.gl.COLOR_BUFFER_BIT)
    },
  }


  // Draw something as a demo
  var actor = new sDemo()

  // Get params from URL hash and update URL when they change
  var param_handler = new sParams({onchange: param_onchange_callbacks})

  // Default params
  param_handler.params = {

      // Scroll position
      x: 0,
      y: 0,

      // Zoom
      z: 1.0,

  }

  // Parse supplies params
  param_handler.parse(false)

  // Update params in URL hash
  param_handler.update()

  // Set sWebGL params
  swgl.gl.uniform2f(swgl.transform_location, param_handler.params.x, param_handler.params.y)
  swgl.gl.uniform1f(swgl.scale_location, param_handler.params.z)

  // Set actor params from URL hash
  for (var param_name in param_handler.params) {
    var indexes = param_name.split('_')
    switch (indexes[0]) {

      case 'param':
        actor.params[indexes[1]] = param_handler.params[param_name]
        // @todo update control panel sliders
        break;

    }
  }

  // Point in time counter (eg. frame number)
  var pot = 0

  var color_offsets = vec3.create()
  vec3.random(color_offsets)
  var color_frequencies = vec3.create()
  vec3.random(color_frequencies, 0.05)

  swgl.drawScene = function() {

    pot++

    if (typeof swgl.plugins === 'object') {
      for (var i in swgl.plugins) if (swgl.plugins[i].hasOwnProperty('whileDown')) {
        for (var j in swgl.plugins[i].whileDown) {
          if (swgl.plugins[i].b[j]) {
            swgl.plugins[i].whileDown[j]()
          }
        }
      }
    }

    // Randomize colour
    //swgl.gl.uniform4f(this.color_location, Math.random(), Math.random(), Math.random(), 1)

    // Siney colour
    swgl.gl.uniform4f(
      this.color_location,
      1 + Math.sin(color_offsets[0] + pot * color_frequencies[0]),
      1 + Math.sin(color_offsets[1] + pot * color_frequencies[1]),
      1 + Math.sin(color_offsets[2] + pot * color_frequencies[2]),
      1
    )

    // Reset initial position
    actor.reset()

    // Iterate
    actor.iterate()
  }

  // Draw the actor control panel
  var panel = new sPanel()

  panel.drawSliders(
    actor.params,
    'param',
    {
      min: 0,
      max: 1,
      onchange: function(name) {
        var indexes = name.split('_')
        param_handler.params[name] = actor.params[indexes[1]].toFixed(3)
        param_handler.update()
      },
    }
  )

}

</script>

</body>
</html>
